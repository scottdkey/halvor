# .envrc - direnv configuration for Halvor
# This file should load environment variables from 1Password vault
#
# To use:
# 1. Install direnv: brew install direnv (or your package manager)
# 2. Install 1Password CLI: brew install --cask 1password-cli
# 3. Copy this file to .envrc: cp .envrc.example .envrc
# 4. Update the vault and item references below
# 5. Run: direnv allow

# Development mode - builds containers locally from repo
export HALVOR_ENV="development"

# Load environment variables from 1Password vault
# Automatically exports all fields from the halvor item in the automations vault
# Add new fields to the vault and they'll automatically be available as environment variables

VAULT_NAME="automations"
ITEM_NAME="halvor"

# Get all fields from the 1Password item and export them as environment variables
# Optimized: Fetch entire item once, extract all values from JSON (no per-field API calls)
# Use tab separator to safely handle values with special characters

# Check if jq is installed
if ! command -v jq >/dev/null 2>&1; then
  echo "⚠️  jq is not installed. Install it with: sudo apt-get install jq" >&2
  echo "⚠️  Environment variables from 1Password will not be loaded." >&2
  exit 0
fi

# Sign in to 1Password if not already signed in
# This ensures we have a valid session before trying to fetch items
# Check if already signed in first to avoid unnecessary prompts
if ! op whoami >/dev/null 2>&1; then
  echo "Not signed in to 1Password." >&2
  echo "Signing in (you will be prompted for your password)..." >&2
  # op signin requires interactive input (password prompt)
  # The standard way is: eval $(op signin --account my)
  # When run this way:
  # - stderr (password prompt) goes to terminal and shows immediately
  # - stdout (session vars) gets captured by command substitution
  # - eval then sets the session variables
  # This should work when direnv allow is run in an interactive terminal
  if eval "$(op signin --account my)"; then
    # Sign-in command executed, verify it worked
    if op whoami >/dev/null 2>&1; then
      echo "✓ Signed in to 1Password" >&2
    else
      echo "⚠️  Sign-in command executed but session is not valid" >&2
      echo "⚠️  Please run 'eval \$(op signin --account my)' manually and then run 'direnv allow'" >&2
      exit 0
    fi
  else
    # Sign-in failed
    echo "⚠️  Failed to sign in to 1Password" >&2
    echo "⚠️  Please run 'eval \$(op signin --account my)' manually first, then run 'direnv allow'" >&2
    exit 0
  fi
fi

# Fetch item from 1Password (show errors if it fails)
ITEM_JSON=$(op item get "${ITEM_NAME}" --vault "${VAULT_NAME}" --format json 2>&1)
OP_EXIT_CODE=$?

if [ $OP_EXIT_CODE -ne 0 ]; then
  echo "⚠️  Failed to fetch 1Password item '${ITEM_NAME}' from vault '${VAULT_NAME}':" >&2
  echo "$ITEM_JSON" >&2
  echo "⚠️  Make sure you're signed in: op signin" >&2
  exit 0
fi

# Check if we got valid JSON
if [ -z "$ITEM_JSON" ] || ! echo "$ITEM_JSON" | jq empty 2>/dev/null; then
  echo "⚠️  Invalid JSON response from 1Password. Item might not exist or be empty." >&2
  exit 0
fi

# Store field names and values in a temp file for display (since while loop runs in subshell)
# Format: field_name\tfield_value
TEMP_FIELDS=$(mktemp)
echo "$ITEM_JSON" | jq -r '.fields[] | 
  select(.type == "STRING" or .type == "CONCEALED" or .type == "EMAIL" or .type == "URL") | 
  select(.label != null and .label != "") | 
  select(.value != null and .value != "") |
  "\(.label)\t\(.value)"' > "$TEMP_FIELDS" 2>&1

# Export all fields that have values in the JSON (most fields)
while IFS=$'\t' read -r field_name field_value; do
  if [ -n "$field_name" ] && [ -n "$field_value" ]; then
    export "${field_name}"="${field_value}"
  fi
done < "$TEMP_FIELDS"

# Display loaded environment variables (obfuscate sensitive values)
# Output to stderr so direnv displays it
LOADED_COUNT=$(wc -l < "$TEMP_FIELDS" 2>/dev/null | tr -d ' ' || echo "0")
if [ "$LOADED_COUNT" -gt 0 ]; then
  echo "✓ Loaded ${LOADED_COUNT} environment variable(s) from 1Password vault '${VAULT_NAME}' item '${ITEM_NAME}':" >&2
  while IFS=$'\t' read -r var_name var_value; do
    # Check if variable name suggests it's sensitive
    if echo "$var_name" | grep -qiE "(PASSWORD|TOKEN|SECRET|KEY|CREDENTIAL)"; then
      echo "  ${var_name}=***hidden***" >&2
    else
      # Truncate long values for display
      if [ ${#var_value} -gt 50 ]; then
        echo "  ${var_name}=${var_value:0:47}..." >&2
      else
        echo "  ${var_name}=${var_value}" >&2
      fi
    fi
  done < "$TEMP_FIELDS"
fi
rm -f "$TEMP_FIELDS"